import { Box3, BufferAttribute, BufferGeometry, InterleavedBufferAttribute, Sphere, } from "three";

/**
 * Service that is used to weld the geometry all together. The aim is to create an indexed geometry
 */
export class BufferGeometryWelder {
  /**
   * Precision to use to weld the geometry
   * @private
   */
  private readonly precision: number;
  /**
   * Destination for the geometry once merged. This will be the returned geometry.
   * @private
   */
  private readonly destinationBufferGeometry: BufferGeometry;
  /**
   * Morph keys.
   * @private
   */
  private readonly morphKeys: string[];
  /**
   * Keys for the attributes of the geometry
   * @private
   */
  private readonly attributesKeys: string[];
  /**
   * List used to numerate the vertices: length is used as the index number that will be used to generate the index buffer.
   * @private
   */
  private readonly vertexIndexList: number[];

  /**
   * Hashmap of the vertex against the index number of the vertex. All vertices that are considered as similar give the same hash code. If a similar vertex is checking its hash, it can know if it duplicated and if it need to be dropped.
   * @private
   */
  private readonly vertexDictionnary: { [hashId: string]: number } = {};

  /**
   * Constructor
   * @param sourceBufferGeometry Buffer geometry that needs to be welded into indexed one.
   * @param isFullComparison If true, the whole list of attributes will be compared to decide if a vertice is shared.
   *   Else, it will merge vertices that are next to each other by only using the position attribute.
   * @param precision Tolerance parameter to decide if we need to merge two vertices. The welder is more tolerant with
   *   a lower value and will simplify the geometry more roughly.
   */
  constructor(
    private readonly sourceBufferGeometry: BufferGeometry,
    isFullComparison = false,
    precision = 6
  ) {
    this.precision = Math.pow(10, precision);
    this.vertexIndexList = [];

    this.destinationBufferGeometry = new BufferGeometry();

    this.attributesKeys = Object.keys(this.sourceBufferGeometry.attributes);
    this.morphKeys = Object.keys(this.sourceBufferGeometry.morphAttributes);
    this.generateIndexedGeometry(isFullComparison);
  }

  /**
   * Returns the indexed buffer geometry generated by the welder.
   * You can dispose the source buffer geometry safely, the two are independents in the welder.
   */
  public getMergedBufferGeometry(): BufferGeometry {
    return this.destinationBufferGeometry;
  }

  /**
   * Applies the precision to determine the eventual common hash code.
   * @param array Attribute array
   * @param offset Offset in the array
   * @private
   */
  private floor(array: ArrayLike<number>, offset: number) {
    if (array instanceof Float32Array) {
      return Math.floor(array[offset] * this.precision);
    } else {
      return array[offset];
    }
  }

  /**
   * Generates the indexed destination geometry.
   * @param isFullComparison Determines if all the attributes must be checked or only position to merge vertices together.
   * @private
   */
  private generateIndexedGeometry(isFullComparison: boolean) {
    const position = this.sourceBufferGeometry.attributes.position.array;

    const attributeSize = 3;
    const numberVertexByFace = 3;
    const faceCount = position.length / attributeSize / numberVertexByFace;

    const ArrayType = faceCount * 3 > 65536 ? Uint32Array : Uint16Array;
    const indexArray = new ArrayType(faceCount * 3);

    // Full index only connects vertices where all attributes are equal

    if (isFullComparison) {
      for (let i = 0; i < faceCount; i++) {
        indexArray[i * 3] = this.determineVertexIndexFromAllAttributesAt(i * 3);
        indexArray[i * 3 + 1] = this.determineVertexIndexFromAllAttributesAt(
          i * 3 + 1
        );
        indexArray[i * 3 + 2] = this.determineVertexIndexFromAllAttributesAt(
          i * 3 + 2
        );
      }
    } else {
      for (let i = 0; i < faceCount; i++) {
        const offset = i * 9;

        indexArray[i * 3] = this.determineVertexIndexFromPositionAt(
          position[offset],
          position[offset + 1],
          position[offset + 2],
          i * 3
        );
        indexArray[i * 3 + 1] = this.determineVertexIndexFromPositionAt(
          position[offset + 3],
          position[offset + 4],
          position[offset + 5],
          i * 3 + 1
        );
        indexArray[i * 3 + 2] = this.determineVertexIndexFromPositionAt(
          position[offset + 6],
          position[offset + 7],
          position[offset + 8],
          i * 3 + 2
        );
      }
    }

    // Index

    this.destinationBufferGeometry.index = new BufferAttribute(indexArray, 1);

    // Attributes

    for (let i = 0, l = this.attributesKeys.length; i < l; i++) {
      const key = this.attributesKeys[i];
      this.destinationBufferGeometry.attributes[key] = this.createAttribute(
        this.sourceBufferGeometry.attributes[key] as BufferAttribute
      );
    }

    // Morph Attributes

    for (let i = 0, l = this.morphKeys.length; i < l; i++) {
      const key = this.morphKeys[i];

      this.destinationBufferGeometry.morphAttributes[key] =
        this.sourceBufferGeometry.morphAttributes[key].map((source) =>
          this.createAttribute(source)
        );
    }

    if (this.sourceBufferGeometry.boundingSphere) {
      this.destinationBufferGeometry.boundingSphere =
        this.sourceBufferGeometry.boundingSphere.clone();
    } else {
      this.destinationBufferGeometry.boundingSphere = new Sphere();
      this.destinationBufferGeometry.computeBoundingSphere();
    }

    if (this.sourceBufferGeometry.boundingBox) {
      this.destinationBufferGeometry.boundingBox =
        this.sourceBufferGeometry.boundingBox.clone();
    } else {
      this.destinationBufferGeometry.boundingBox = new Box3();
      this.destinationBufferGeometry.computeBoundingBox();
    }

    // Groups

    const groups = this.sourceBufferGeometry.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];

      this.destinationBufferGeometry.addGroup(
        group.start,
        group.count,
        group.materialIndex
      );
    }
  }

  /**
   * Determines the shared vertex index for the full set of attributes.
   * @param position Index position offset of the element in the buffer attribute. (For example, the number of the Vector3 in the position attribute)
   * @returns The index of the shared vertices if it exists or the current index of the vertex by setting it as reference for other similar vertices.
   * @private
   */
  private determineVertexIndexFromAllAttributesAt(position: number): number {
    let hashId = "";

    for (const key of this.attributesKeys) {
      const attribute = this.sourceBufferGeometry.attributes[key];
      const offset = attribute.itemSize * position;
      hashId += this.hashAttribute(attribute, offset) + "_";
    }

    for (const key of this.morphKeys) {
      this.sourceBufferGeometry.morphAttributes[key].forEach(
        (morphAttribute) => {
          const offset = morphAttribute.itemSize * position;
          hashId += this.hashAttribute(morphAttribute, offset) + "_";
        }
      );
    }

    if (this.vertexDictionnary[hashId] === undefined) {
      this.vertexDictionnary[hashId] = this.vertexIndexList.length;

      this.vertexIndexList.push(position);
    }

    return this.vertexDictionnary[hashId];
  }

  /**
   * Determines the shared vertex index for the position attribute only.
   * @param x X position of the vertex
   * @param y Y position of the vertex
   * @param z Z position of the vertex
   * @param index index of the vertex
   * @returns The index of the shared vertices if it exists or the current index of the vertex by setting it as reference for other similar vertices.
   * @private
   */
  private determineVertexIndexFromPositionAt(
    x: number,
    y: number,
    z: number,
    index: number
  ) {
    const hashId =
      Math.floor(x * this.precision) +
      "_" +
      Math.floor(y * this.precision) +
      "_" +
      Math.floor(z * this.precision);

    if (this.vertexDictionnary[hashId] === undefined) {
      this.vertexDictionnary[hashId] = this.vertexIndexList.length;
      this.vertexIndexList.push(index); //By pushing, increment the next nÂ° of the next vertex
    }

    return this.vertexDictionnary[hashId];
  }

  /**
   * Create a new destination attribute based on the source one for indexed geometry, depending on the item size stored in the source attribute.
   * @param sourceAttribute Source attribute to weld
   * @returns a welded buffer attribute
   * @private
   */
  private createAttribute(
    sourceAttribute: BufferAttribute | InterleavedBufferAttribute
  ): BufferAttribute {
    const destinationAttribute = new BufferAttribute(
      new Float32Array(this.vertexIndexList.length * sourceAttribute.itemSize),
      sourceAttribute.itemSize
    );

    const destinationArray = Array.from(destinationAttribute.array);
    const sourceArray = Array.from(sourceAttribute.array);

    switch (sourceAttribute.itemSize) {
      case 1:
        for (let i = 0, l = this.vertexIndexList.length; i < l; i++) {
          destinationArray[i] = sourceArray[this.vertexIndexList[i]];
        }

        break;
      case 2:
        for (let i = 0, l = this.vertexIndexList.length; i < l; i++) {
          const index = this.vertexIndexList[i] * 2;
          const offset = i * 2;

          destinationArray[offset] = sourceArray[index];
          destinationArray[offset + 1] = sourceArray[index + 1];
        }

        break;
      case 3:
        for (let i = 0, l = this.vertexIndexList.length; i < l; i++) {
          const index = this.vertexIndexList[i] * 3;
          const offset = i * 3;

          destinationArray[offset] = sourceArray[index];
          destinationArray[offset + 1] = sourceArray[index + 1];
          destinationArray[offset + 2] = sourceArray[index + 2];
        }

        break;
      case 4:
        for (let i = 0, l = this.vertexIndexList.length; i < l; i++) {
          const index = this.vertexIndexList[i] * 4;
          const offset = i * 4;

          destinationArray[offset] = sourceArray[index];
          destinationArray[offset + 1] = sourceArray[index + 1];
          destinationArray[offset + 2] = sourceArray[index + 2];
          destinationArray[offset + 3] = sourceArray[index + 3];
        }

        break;
    }

    destinationAttribute.set(destinationArray);
    return destinationAttribute;
  }

  /**
   * Generates the hash based on the item size of the buffer attribute.
   * @param attribute Attribute information
   * @param offset Offset of the element in the attribute's array
   * @returns the hash code
   * @private
   */
  private hashAttribute(
    attribute: BufferAttribute | InterleavedBufferAttribute,
    offset: number
  ): string {
    const array = attribute.array;

    switch (attribute.itemSize) {
      case 1:
        return this.floor(array, offset).toString();

      case 2:
        return this.floor(array, offset) + "_" + this.floor(array, offset + 1);

      case 3:
        return (
          this.floor(array, offset) +
          "_" +
          this.floor(array, offset + 1) +
          "_" +
          this.floor(array, offset + 2)
        );

      case 4:
        return (
          this.floor(array, offset) +
          "_" +
          this.floor(array, offset + 1) +
          "_" +
          this.floor(array, offset + 2) +
          "_" +
          this.floor(array, offset + 3)
        );
    }
    throw new Error(`This itemSize for the attribute is unsupported: ${attribute.itemSize}. Must be either 1, 2, 3 or 4.`)
  }
}
